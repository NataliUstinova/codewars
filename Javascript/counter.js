// Count — это функция-конструктор.
// Внутри нее объявляется переменная counter, которая доступна только в замыкании.
// Замыкание → Функция, которая "помнит" внешние переменные.
// Count возвращает анонимную функцию, которая увеличивает и выводит counter.
function Count() {
  let counter = 0; // Эта переменная сохраняется в замыкании
  
  return () => {
    console.log(counter++)
  }
}

const c = new Count();
// Ошибка! Count — обычная функция, а не конструктор.
// Если мы вызываем new Count(), то Count не возвращает this, а вместо этого возвращает функцию.
// Поэтому c становится функцией, а не объектом.

c(); //0
c(); //1
//c — это функция, возвращенная из Count(), и она имеет доступ к counter внутри замыкания.
//При каждом вызове она увеличивает и выводит counter.

c.counter = 0
// Ошибка! Count — обычная функция, а не конструктор.
// Если мы вызываем new Count(), то Count не возвращает this, а вместо этого возвращает функцию.
// Поэтому c становится функцией, а не объектом.
//Это не изменяет внутреннюю переменную counter в замыкании.
// Вместо этого создается новое свойство counter у функции c, которое никак не влияет на counter внутри замыкания.

c(); // 2
//Еще один вызов c()

const b = new Count();

b();
// Создается новое замыкание со своим counter = 0.
// Поэтому b(); выведет 0, независимо от c.

// Count не является конструктором (хотя вызывается через new).
// c и b — это функции с независимыми замыканиями.
// c.counter = 0 не влияет на внутренний counter.
// Исправленный вызов без new:
// const c = Count(); // просто вызываем функцию, без `new`

